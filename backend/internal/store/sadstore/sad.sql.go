// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: sad.sql

package sadstore

import (
	"context"
)

const createSad = `-- name: CreateSad :exec
insert into sads (user_id, name, reason) 
values ($1, $2, $3)
`

type CreateSadParams struct {
	UserID int32  `db:"user_id" json:"user_id"`
	Name   string `db:"name" json:"name"`
	Reason string `db:"reason" json:"reason"`
}

func (q *Queries) CreateSad(ctx context.Context, arg CreateSadParams) error {
	_, err := q.exec(ctx, q.createSadStmt, createSad, arg.UserID, arg.Name, arg.Reason)
	return err
}

const deleteSadById = `-- name: DeleteSadById :exec
delete from sads where id = $1
`

func (q *Queries) DeleteSadById(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteSadByIdStmt, deleteSadById, id)
	return err
}

const getSadById = `-- name: GetSadById :one
select id, user_id, name, reason from sads
where id = $1
limit 1
`

func (q *Queries) GetSadById(ctx context.Context, id int32) (Sad, error) {
	row := q.queryRow(ctx, q.getSadByIdStmt, getSadById, id)
	var i Sad
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Reason,
	)
	return i, err
}

const getSadByUserId = `-- name: GetSadByUserId :many
select id, user_id, name, reason from sads
where user_id in (
    select u.id from users u
    where u.id = $1
)
`

func (q *Queries) GetSadByUserId(ctx context.Context, id int32) ([]Sad, error) {
	rows, err := q.query(ctx, q.getSadByUserIdStmt, getSadByUserId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sad
	for rows.Next() {
		var i Sad
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSads = `-- name: GetSads :many
select id, user_id, name, reason from sads
`

func (q *Queries) GetSads(ctx context.Context) ([]Sad, error) {
	rows, err := q.query(ctx, q.getSadsStmt, getSads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sad
	for rows.Next() {
		var i Sad
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSad = `-- name: UpdateSad :exec
update sads set 
name = $1,
reason = $2
where id = $3
`

type UpdateSadParams struct {
	Name   string `db:"name" json:"name"`
	Reason string `db:"reason" json:"reason"`
	ID     int32  `db:"id" json:"id"`
}

func (q *Queries) UpdateSad(ctx context.Context, arg UpdateSadParams) error {
	_, err := q.exec(ctx, q.updateSadStmt, updateSad, arg.Name, arg.Reason, arg.ID)
	return err
}
