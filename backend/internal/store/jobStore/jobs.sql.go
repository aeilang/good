// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package jobStore

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createJob = `-- name: CreateJob :exec
insert into jobs (
    id, href, company_name, company_image, title, keyword, city, 
    fulltime, job_type, description, requirement, price_down, price_up
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type CreateJobParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	Href         string    `db:"href" json:"href"`
	CompanyName  string    `db:"company_name" json:"company_name"`
	CompanyImage string    `db:"company_image" json:"company_image"`
	Title        string    `db:"title" json:"title"`
	Keyword      []string  `db:"keyword" json:"keyword"`
	City         string    `db:"city" json:"city"`
	Fulltime     bool      `db:"fulltime" json:"fulltime"`
	JobType      string    `db:"job_type" json:"job_type"`
	Description  string    `db:"description" json:"description"`
	Requirement  string    `db:"requirement" json:"requirement"`
	PriceDown    int32     `db:"price_down" json:"price_down"`
	PriceUp      int32     `db:"price_up" json:"price_up"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) error {
	_, err := q.exec(ctx, q.createJobStmt, createJob,
		arg.ID,
		arg.Href,
		arg.CompanyName,
		arg.CompanyImage,
		arg.Title,
		pq.Array(arg.Keyword),
		arg.City,
		arg.Fulltime,
		arg.JobType,
		arg.Description,
		arg.Requirement,
		arg.PriceDown,
		arg.PriceUp,
	)
	return err
}

const deleteJobById = `-- name: DeleteJobById :exec
update jobs set
is_deleted = true
where id = $1
`

func (q *Queries) DeleteJobById(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteJobByIdStmt, deleteJobById, id)
	return err
}

const getAllJobs = `-- name: GetAllJobs :many
select id, company_name,company_image, title, city, fulltime, job_type, keyword, price_down, price_up,
COUNT(*) OVER() as total
from jobs
where is_deleted = false
AND (price_down >= $3::integer or $3 = 0)
AND (price_up <= $4::integer or $4 = 0)
AND (to_tsvector('simple', title) @@ plainto_tsquery('simple', $5::text) or $5 = '')
AND (to_tsvector('simple', company_name) @@ plainto_tsquery('simple', $6::text) or $6 = '')
AND (city = $7::text or $7 = '')
AND (job_type = $8::text or $8 = '')
ORDER BY $9::text, id ASC
LIMIT $1 OFFSET $2
`

type GetAllJobsParams struct {
	Limit       int32  `db:"limit" json:"limit"`
	Offset      int32  `db:"offset" json:"offset"`
	PriceDown   int32  `db:"price_down" json:"price_down"`
	PriceUp     int32  `db:"price_up" json:"price_up"`
	Title       string `db:"title" json:"title"`
	Companyname string `db:"companyname" json:"companyname"`
	City        string `db:"city" json:"city"`
	Jobtype     string `db:"jobtype" json:"jobtype"`
	Oderby      string `db:"oderby" json:"oderby"`
}

type GetAllJobsRow struct {
	ID           uuid.UUID `db:"id" json:"id"`
	CompanyName  string    `db:"company_name" json:"company_name"`
	CompanyImage string    `db:"company_image" json:"company_image"`
	Title        string    `db:"title" json:"title"`
	City         string    `db:"city" json:"city"`
	Fulltime     bool      `db:"fulltime" json:"fulltime"`
	JobType      string    `db:"job_type" json:"job_type"`
	Keyword      []string  `db:"keyword" json:"keyword"`
	PriceDown    int32     `db:"price_down" json:"price_down"`
	PriceUp      int32     `db:"price_up" json:"price_up"`
	Total        int64     `db:"total" json:"total"`
}

func (q *Queries) GetAllJobs(ctx context.Context, arg GetAllJobsParams) ([]GetAllJobsRow, error) {
	rows, err := q.query(ctx, q.getAllJobsStmt, getAllJobs,
		arg.Limit,
		arg.Offset,
		arg.PriceDown,
		arg.PriceUp,
		arg.Title,
		arg.Companyname,
		arg.City,
		arg.Jobtype,
		arg.Oderby,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsRow
	for rows.Next() {
		var i GetAllJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyName,
			&i.CompanyImage,
			&i.Title,
			&i.City,
			&i.Fulltime,
			&i.JobType,
			pq.Array(&i.Keyword),
			&i.PriceDown,
			&i.PriceUp,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobById = `-- name: GetJobById :one
select href, company_image, company_name, title, city, fulltime, job_type, description, requirement, price_down, price_up, version
from jobs
where id = $1
and is_deleted = false
`

type GetJobByIdRow struct {
	Href         string `db:"href" json:"href"`
	CompanyImage string `db:"company_image" json:"company_image"`
	CompanyName  string `db:"company_name" json:"company_name"`
	Title        string `db:"title" json:"title"`
	City         string `db:"city" json:"city"`
	Fulltime     bool   `db:"fulltime" json:"fulltime"`
	JobType      string `db:"job_type" json:"job_type"`
	Description  string `db:"description" json:"description"`
	Requirement  string `db:"requirement" json:"requirement"`
	PriceDown    int32  `db:"price_down" json:"price_down"`
	PriceUp      int32  `db:"price_up" json:"price_up"`
	Version      int32  `db:"version" json:"version"`
}

func (q *Queries) GetJobById(ctx context.Context, id uuid.UUID) (GetJobByIdRow, error) {
	row := q.queryRow(ctx, q.getJobByIdStmt, getJobById, id)
	var i GetJobByIdRow
	err := row.Scan(
		&i.Href,
		&i.CompanyImage,
		&i.CompanyName,
		&i.Title,
		&i.City,
		&i.Fulltime,
		&i.JobType,
		&i.Description,
		&i.Requirement,
		&i.PriceDown,
		&i.PriceUp,
		&i.Version,
	)
	return i, err
}

const updateJobById = `-- name: UpdateJobById :exec
update jobs
set href = $1, company_image = $2, company_name = $3, title = $4, keyword = $5, city = $6, 
fulltime = $7, job_type = $8, description = $9, requirement = $10,
price_down = $11, price_up = $12, version = version+1
where id = $13 and version = $14
`

type UpdateJobByIdParams struct {
	Href         string    `db:"href" json:"href"`
	CompanyImage string    `db:"company_image" json:"company_image"`
	CompanyName  string    `db:"company_name" json:"company_name"`
	Title        string    `db:"title" json:"title"`
	Keyword      []string  `db:"keyword" json:"keyword"`
	City         string    `db:"city" json:"city"`
	Fulltime     bool      `db:"fulltime" json:"fulltime"`
	JobType      string    `db:"job_type" json:"job_type"`
	Description  string    `db:"description" json:"description"`
	Requirement  string    `db:"requirement" json:"requirement"`
	PriceDown    int32     `db:"price_down" json:"price_down"`
	PriceUp      int32     `db:"price_up" json:"price_up"`
	ID           uuid.UUID `db:"id" json:"id"`
	Version      int32     `db:"version" json:"version"`
}

func (q *Queries) UpdateJobById(ctx context.Context, arg UpdateJobByIdParams) error {
	_, err := q.exec(ctx, q.updateJobByIdStmt, updateJobById,
		arg.Href,
		arg.CompanyImage,
		arg.CompanyName,
		arg.Title,
		pq.Array(arg.Keyword),
		arg.City,
		arg.Fulltime,
		arg.JobType,
		arg.Description,
		arg.Requirement,
		arg.PriceDown,
		arg.PriceUp,
		arg.ID,
		arg.Version,
	)
	return err
}
